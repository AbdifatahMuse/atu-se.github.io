<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="dcterms.date" content="2019-02-24">
  <title>DSA Lecture</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/reveal.css">
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/theme/beige.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../../../presentation/reveal.js/css/print/pdf.css' : '../../../presentation/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="../../../presentation/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="../../../presentation/katex/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="../../../presentation/katex/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">DSA Lecture</h1>
  <p class="subtitle">5. Developing Efficient Algorithms</p>
  <p class="date">February 24, 2019</p>
</section>

<section><section id="introduction-221" class="title-slide slide level1"><h1>Introduction (22.1)</h1></section><section id="objectives" class="slide level2">
<h2>Objectives</h2>
<ul>
<li>To estimate algorithm efficiency using the Big O notation (§22.2).</li>
<li>To explain growth rates and why constants and nondominating terms can be ignored in the estimation (§22.2).</li>
<li>To determine the complexity of various types of algorithms (§22.3).</li>
<li>To analyze the binary search algorithm (§22.4.1).</li>
<li>To analyze the selection sort algorithm (§22.4.2).</li>
</ul>
</section><section id="objectives-1" class="slide level2">
<h2>Objectives</h2>
<ul>
<li>To analyze the Tower of Hanoi algorithm (§22.4.3).</li>
<li>To describe common growth functions (constant, logarithmic, log- linear, quadratic, cubic, exponential) (§22.4.4).</li>
<li>To design efficient algorithms for finding Fibonacci numbers using dynamic programming (§22.5).</li>
<li>To find the GCD using Euclid’s algorithm (§22.6).</li>
<li>To find prime numbers using the sieve of Eratosthenes (§22.7).</li>
</ul>
</section><section id="objectives-2" class="slide level2">
<h2>Objectives</h2>
<ul>
<li>To design efficient algorithms for finding the closest pair of points using the divide-and-conquer approach (§22.8).</li>
<li>To solve the Eight Queens problem using the backtracking approach (§22.9).</li>
<li>To design efficient algorithms for finding a convex hull for a set of points (§22.10).</li>
</ul>
</section><section id="introduction" class="slide level2">
<h2>Introduction</h2>
<ul>
<li>Algorithm design is to develop a mathematical process for solving a problem. Algorithm analysis is to predict the performance of an algorithm.</li>
<li>This chapter will use a variety of examples to introduce common algorithmic techniques (dynamic programming, divide-and-conquer, and backtracking) for developing efficient algorithms</li>
<li>Before introducing developing efficient algorithms, we need to address the question on how to measure algorithm efficiency.</li>
</ul>
</section></section>
<section><section id="measuring-efficiency-222" class="title-slide slide level1"><h1>Measuring Efficiency (22.2)</h1></section><section id="big-o-notation" class="slide level2">
<h2>Big O Notation</h2>
<ul>
<li>The Big O notation obtains a function for measuring algorithm time complexity based on the input size.</li>
<li>You can ignore multiplicative constants and nondominating terms in the function.</li>
</ul>
</section><section id="comparing-search-algorithms" class="slide level2">
<h2>Comparing Search Algorithms</h2>
<ul>
<li>Suppose two algorithms perform the same task, such as search (<em>linear search</em> vs. <em>binary search</em>).</li>
<li>Which one is better?</li>
</ul>
</section><section id="measuring-runtime" class="slide level2">
<h2>Measuring Runtime</h2>
<ul>
<li>To answer this question, you might implement these algorithms and run the programs to get execution time. But there are two problems with this approach:
<ul>
<li>First, many tasks run concurrently on a computer. The execution time of a particular program depends on the <em>system load</em>.</li>
<li>Second, the execution time depends on <em>specific input</em>. Consider, for example, linear search and binary search. If an element to be searched happens to be the first in the list, linear search will find the element quicker than binary search.</li>
</ul></li>
</ul>
</section><section id="growth-rates" class="slide level2">
<h2>Growth Rates</h2>
<ul>
<li>It is very difficult to compare algorithms by measuring their execution time.</li>
<li>To overcome these problems, a theoretical approach was developed to analyze algorithms independent of computers and specific input.</li>
<li>This approach approximates the effect of a change on the size of the input.</li>
<li>In this way, you can see how fast an algorithm’s execution time increases as the input size increases, so you can compare two algorithms by examining their <strong>growth rates</strong>.</li>
</ul>
</section><section id="measuring-runtime-1" class="slide level2">
<h2>Measuring Runtime</h2>
<ul>
<li>For the same input size, an algorithm’s execution time may vary, depending on the input.</li>
<li>An input that results in the shortest execution time is called the best-case input,</li>
<li>An input that results in the longest execution time is the worst-case input.</li>
</ul>
</section><section id="measuring-runtime-2" class="slide level2">
<h2>Measuring Runtime</h2>
<ul>
<li><strong>Best-case analysis</strong> and <strong>worst-case analysis</strong> are to analyze the algorithms for their best-case input and worst-case input.</li>
<li>Best-case and worst-case analysis are not representative</li>
<li>Worst-case analysis is very useful. You can be assured that the algorithm will never be slower than the worst case.</li>
</ul>
</section><section id="measuring-runtime-3" class="slide level2">
<h2>Measuring Runtime</h2>
<ul>
<li>An <strong>average-case analysis</strong> attempts to determine the average amount of time among all possible inputs of the same size.</li>
<li>Average-case analysis is ideal, but difficult to perform, because for many problems it is hard to determine the relative probabilities and distributions of various input instances.</li>
<li>Worst-case analysis is easier to perform, so the analysis is generally conducted for the worst case.</li>
</ul>
</section><section id="example-linear-search" class="slide level2">
<h2>Example: Linear Search</h2>
<ul>
<li>The linear search algorithm compares the key with the elements in the array sequentially until the key is found or the array is exhausted.</li>
<li>If the key is not in the array, it requires n comparisons for an array of size n.</li>
<li>If the key is in the array, it requires n/2 comparisons on average.</li>
<li>The algorithm’s execution time is proportional to the size of the array.</li>
</ul>
</section><section id="example-linear-search-1" class="slide level2">
<h2>Example: Linear Search</h2>
<ul>
<li>If you double the size of the array, you will expect the number of comparisons to double.</li>
<li>The algorithm grows at a linear rate. The growth rate has an order of magnitude of n.</li>
<li>Computer scientists use the Big O notation to represent the “order of magnitude.”</li>
<li>Using this notation, the complexity of the linear search algorithm is O(n), pronounced as “order of n.”</li>
</ul>
</section><section id="example-linear-search-2" class="slide level2">
<h2>Example: Linear Search</h2>
<table>
<thead>
<tr class="header">
<th>n\f(n)</th>
<th>n</th>
<th>n/2</th>
<th>100n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>100</td>
<td>50</td>
<td>10,000</td>
</tr>
<tr class="even">
<td>200</td>
<td>200</td>
<td>100</td>
<td>20,000</td>
</tr>
</tbody>
</table>
<ul>
<li>f(n) = n, f(n) = n/2 and f(n) = 100n are all linear functions</li>
<li>Doubling the size of n does yields the same growth rate for all three functions</li>
</ul>
</section><section id="example-array-maximum" class="slide level2">
<h2>Example: Array Maximum</h2>
<ul>
<li>Consider the algorithm for finding the maximum number in an array of n elements.</li>
<li>To find the maximum number if n is 2, it takes one comparison;</li>
<li>if n is 3, two comparisons.</li>
<li>In general, it takes n - 1 comparisons to find the maximum number in a list of n elements.</li>
<li>So what is the order of magnitude for this algorithm? Hint: it’s not O(n-1)</li>
</ul>
</section><section id="example-array-maximum-1" class="slide level2">
<h2>Example: Array Maximum</h2>
<ul>
<li>Algorithm analysis is for large input size.</li>
<li>If the input size is small, there is no significance in estimating an algorithm’s efficiency.</li>
<li>As n grows larger, the n part in the expression n - 1 dominates the complexity.</li>
<li><strong>The Big O notation allows you to ignore the nondominating part</strong> (e.g., -1 in the expression n - 1) and <strong>highlight the important part</strong> (e.g., n in the expression n - 1).</li>
<li>Therefore, the complexity of this algorithm is O(n).</li>
</ul>
</section><section id="constant-time" class="slide level2">
<h2>Constant Time</h2>
<ul>
<li>If the time is not related to the input size, the algorithm is said to take constant time with the notation O(1).</li>
<li>For example, a method that retrieves an element at a given index in an array takes <em>constant time</em>, because the time does not grow as the size of the array increases.</li>
</ul>
</section><section id="other-examples" class="slide level2">
<h2>Other Examples</h2>
<ul>
<li>So far you have seen examples of:
<ul>
<li>O(n) “Linear”</li>
<li>O(1) “Constant time”</li>
</ul></li>
<li>There are other orders of magnitude</li>
</ul>
</section><section id="other-examples-1" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">1 + 2 + 3 + ... + (n-2) + (n-1) = \frac{n(n-1)}{2} = O(?)</span></p>
</section><section id="other-examples-2" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">1 + 2 + 3 + ... + (n-2) + (n-1) = \frac{n(n-1)}{2} = O(n^2)</span></p>
</section><section id="other-examples-3" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">1 + 2 + 3 + ... + (n-1) + (n) = \frac{n(n+1)}{2} = O(?)</span></p>
</section><section id="other-examples-4" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">1 + 2 + 3 + ... + (n-1) + (n) = \frac{n(n+1)}{2} = O(n^2)</span></p>
</section><section id="other-examples-5" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">a^0 + a^1 + a^2 + a^3 + ... + a^{n-1} + a^n  = \frac{a^{n+1} - 1}{a-1} = O(?)</span></p>
</section><section id="other-examples-6" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">a^0 + a^1 + a^2 + a^3 + ... + a^{n-1} + a^n  = \frac{a^{n+1} - 1}{a-1} = O(a^n)</span></p>
</section><section id="other-examples-7" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">2^0 + 2^1 + 2^2 + 2^3 + ... + 2^{n-1} + 2^n  = \frac{2^{n+1} - 1}{2-1} = O(?)</span></p>
</section><section id="other-examples-8" class="slide level2">
<h2>Other Examples</h2>
<p><span class="math display">2^0 + 2^1 + 2^2 + 2^3 + ... + a^{n-1} + 2^n  = \frac{2^{n+1} - 1}{2-1} = O(2^n)</span></p>
</section><section id="orders-of-magnitude-covered" class="slide level2">
<h2>Orders of Magnitude Covered</h2>
<ul>
<li>O(1) “Constant time”</li>
<li>O(n) “Linear”</li>
<li>O(n^2) “Quadratic”</li>
<li>O(2^n) “Exponential”</li>
</ul>
</section><section id="two-complexity-measures" class="slide level2">
<h2>Two Complexity Measures</h2>
<ul>
<li><em>Time complexity</em> is a measure of execution time using the Big-O notation. Similarly, you can also measure space complexity using the Big-O notation.</li>
<li><em>Space complexity</em> measures the amount of memory space used by an algorithm.
<ul>
<li>The space complexity for most algorithms presented in the book is O(n). i.e., they exibit linear growth rate to the input size.</li>
<li>For example, the space complexity for linear search is O(n).</li>
</ul></li>
</ul>
</section></section>
<section><section id="determining-big-o-223" class="title-slide slide level1"><h1>Determining Big O (22.3)</h1></section><section id="big-o-example-1" class="slide level2">
<h2>Big O Example 1</h2>
<p>Consider the time complexity for the following loop:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb1-2" title="2">  k = k + <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-3" title="3">}</a></code></pre></div>
</section><section id="big-o-example-1-1" class="slide level2">
<h2>Big O Example 1</h2>
<ul>
<li>The statement <code>k = k + 5;</code> is a constant time, <em>c</em>.<br />
</li>
<li>When it is put inside of the for loop, <code>for (int i = 1; i &lt;= n; i++)</code>, the time complexity becomes:</li>
</ul>
<p>T(n) = ( a constant <em>c</em> ) * n = O(n)</p>
</section><section id="big-o-example-2" class="slide level2">
<h2>Big O Example 2</h2>
<p>Consider the time complexity for the following loop:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; j++) {</a>
<a class="sourceLine" id="cb2-3" title="3">    k = k + i + j;</a>
<a class="sourceLine" id="cb2-4" title="4">  }</a>
<a class="sourceLine" id="cb2-5" title="5">}</a></code></pre></div>
</section><section id="big-o-example-2-1" class="slide level2">
<h2>Big O Example 2</h2>
<ul>
<li>The statement <code>k = k + i + j;</code> is a constant time, <em>c</em>.<br />
</li>
<li>The inner loop runs j times</li>
<li>The outer loop runs i times</li>
<li>So how many total times does the addition statement run?</li>
</ul>
</section><section id="big-o-example-2-2" class="slide level2">
<h2>Big O Example 2</h2>
<p>The time complexity for this loop is:</p>
<p>T(n) = (a constant <em>c</em>) * n * n = O(n<sup>2</sup>)</p>
<ul>
<li>O(n<sup>2</sup>) is called a <strong>quadratic algorithm</strong>. When input size is doubled, the time quadruples</li>
<li>Nested loops often create quadratic Big O’s</li>
</ul>
</section><section id="big-o-example-3" class="slide level2">
<h2>Big O Example 3</h2>
<p>Consider the time complexity for the following loop:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= i; j++) {</a>
<a class="sourceLine" id="cb3-3" title="3">    k = k + i + j;</a>
<a class="sourceLine" id="cb3-4" title="4">  }</a>
<a class="sourceLine" id="cb3-5" title="5">}</a></code></pre></div>
</section><section id="big-o-example-3-1" class="slide level2">
<h2>Big O Example 3</h2>
<ul>
<li>The outer loop runs n times</li>
<li>The inner loop is executed 1 time, then 2 times, then 3 times… up to n times.</li>
<li>What is the time complexity?</li>
</ul>
</section><section id="big-o-example-3-2" class="slide level2">
<h2>Big O Example 3</h2>
<p><span class="math display"> \begin{aligned}T(n) &amp;= c + 2c + 3c + 4c + ... + nc \\ &amp;= cn (n+1)/2 \\ &amp;= (c / 2) n^2 + (c / 2) n \\ &amp;= O(n^2)
 \end{aligned} </span></p>
</section><section id="big-o-example-4" class="slide level2">
<h2>Big O Example 4</h2>
<p>Consider the time complexity for the following loop:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= <span class="dv">20</span>; j++) {</a>
<a class="sourceLine" id="cb4-3" title="3">    k = k + i + j;</a>
<a class="sourceLine" id="cb4-4" title="4">  }</a>
<a class="sourceLine" id="cb4-5" title="5">}</a></code></pre></div>
</section><section id="big-o-example-4-1" class="slide level2">
<h2>Big O Example 4</h2>
<ul>
<li>The inner loop executes 20 times, and the outer loop n times. Therefore, the time complexity for the loop is:</li>
</ul>
<p><span class="math display"> \begin{aligned}T(n) &amp;= 20*c*n \\ &amp;= O(n)
 \end{aligned} </span></p>
</section><section id="big-o-example-5" class="slide level2">
<h2>Big O Example 5</h2>
<p>Consider the time complexity for the following loop:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= <span class="dv">10</span>; j++) {</a>
<a class="sourceLine" id="cb5-2" title="2">  k = k + <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb5-3" title="3">}</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= <span class="dv">20</span>; j++) {</a>
<a class="sourceLine" id="cb5-6" title="6">    k = k + i + j;</a>
<a class="sourceLine" id="cb5-7" title="7">  }</a>
<a class="sourceLine" id="cb5-8" title="8">}</a></code></pre></div>
</section><section id="big-o-example-5-1" class="slide level2">
<h2>Big O Example 5</h2>
<ul>
<li>The first loop executes 10 times</li>
<li>The second loop executes 20*n times</li>
<li>What is the Big O for this code?</li>
</ul>
<p><span class="math display"> \begin{aligned}T(n) &amp;= 10*c + 20*c*n \\ &amp;= O(?)
  \end{aligned} </span></p>
</section><section id="big-o-example-5-2" class="slide level2">
<h2>Big O Example 5</h2>
<ul>
<li>The first loop executes 10 times</li>
<li>The second loop executes 20*n times</li>
<li><p>What is the Big O for this code?</p>
<p><span class="math display"> \begin{aligned}T(n) &amp;= 10*c + 20*c*n \\ &amp;= O(n)
 \end{aligned} </span></p></li>
</ul>
</section><section id="big-o-example-6" class="slide level2">
<h2>Big O Example 6</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">if</span> (list.<span class="fu">contains</span>(e)) {     </a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(e);</a>
<a class="sourceLine" id="cb6-3" title="3">}</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">else</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="kw">for</span> (<span class="bu">Object</span> t: list) {</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(t);</a>
<a class="sourceLine" id="cb6-7" title="7">  }</a></code></pre></div>
<ul>
<li>Suppose the list contains n elements</li>
<li>The execution time for list.contains(e) is O(n)</li>
<li>The loop in the else clause takes O(n) time.</li>
<li>What is the time complexity for the entire statement?</li>
</ul>
</section><section id="big-o-example-6-1" class="slide level2">
<h2>Big O Example 6</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">if</span> (list.<span class="fu">contains</span>(e)) {     </a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(e);</a>
<a class="sourceLine" id="cb7-3" title="3">}</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">else</span></a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="kw">for</span> (<span class="bu">Object</span> t: list) {</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(t);</a>
<a class="sourceLine" id="cb7-7" title="7">  }</a></code></pre></div>
<p><span class="math display"> \begin{aligned}T(n) &amp;= if\ test\ time + worstcase\ test\ time \\ &amp;= O(n) + O(n) \\ &amp;= O(?)
 \end{aligned} </span></p>
</section><section id="big-o-example-6-2" class="slide level2">
<h2>Big O Example 6</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">if</span> (list.<span class="fu">contains</span>(e)) {     </a>
<a class="sourceLine" id="cb8-2" title="2"> <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(e);</a>
<a class="sourceLine" id="cb8-3" title="3">}</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">else</span></a>
<a class="sourceLine" id="cb8-5" title="5"> <span class="kw">for</span> (<span class="bu">Object</span> t: list) {</a>
<a class="sourceLine" id="cb8-6" title="6">   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(t);</a>
<a class="sourceLine" id="cb8-7" title="7"> }</a></code></pre></div>
<p><span class="math display"> \begin{aligned}T(n) &amp;= if\ test\ time + worstcase\ test\ time \\ &amp;= O(n) + O(n) \\ &amp;= O(n)
\end{aligned} </span></p>
</section><section id="big-o-example-7" class="slide level2">
<h2>Big O Example 7</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb9-1" title="1">result = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)</a>
<a class="sourceLine" id="cb9-3" title="3">  result *= a;</a></code></pre></div>
<p>What is the execution time?</p>
</section><section id="big-o-example-7-1" class="slide level2">
<h2>Big O Example 7</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb10-1" title="1">result = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)</a>
<a class="sourceLine" id="cb10-3" title="3">  result *= a;</a></code></pre></div>
<p><span class="math display"> O(n) </span></p>
</section><section id="big-o-example-7-2" class="slide level2">
<h2>Big O Example 7</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb11-1" title="1">result = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)</a>
<a class="sourceLine" id="cb11-3" title="3">  result *= a;</a></code></pre></div>
<p>What if we knew that <span class="math inline">n=2^k</span> for some k?</p>
</section><section id="big-o-example-7-3" class="slide level2">
<h2>Big O Example 7</h2>
<p>We could improve the algorithm like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb12-1" title="1">result = a;</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= k; i++)</a>
<a class="sourceLine" id="cb12-3" title="3">  result = result*result;</a></code></pre></div>
<p>We don’t know that <span class="math inline">n=2^k</span> for some k, but the algorithm can be revised to prove that the complexity is still O(log n) for the general case for n.</p>
</section></section>
<section><section id="practice" class="title-slide slide level1"><h1>Practice</h1></section><section id="practice-1-count-iterations" class="slide level2">
<h2>Practice 1: Count Iterations</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">int</span> count = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">while</span> (count &lt; <span class="dv">30</span>) {</a>
<a class="sourceLine" id="cb13-3" title="3">  count = count * <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb13-4" title="4">}</a></code></pre></div>
</section><section id="practice-2-count-iterations" class="slide level2">
<h2>Practice 2: Count Iterations</h2>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">int</span> count = <span class="dv">15</span>;</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">while</span> (count &lt; <span class="dv">30</span>) {</a>
<a class="sourceLine" id="cb14-3" title="3">  count = count * <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb14-4" title="4">}</a></code></pre></div>
</section><section id="practice-3-count-stars" class="slide level2">
<h2>Practice 3: Count Stars</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="ch">&#39;*&#39;</span>);</a>
<a class="sourceLine" id="cb15-3" title="3">}</a></code></pre></div>
</section><section id="practice-4-count-iterations" class="slide level2">
<h2>Practice 4: Count Iterations</h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++) {</a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) {</a>
<a class="sourceLine" id="cb16-4" title="4">      <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="ch">&#39;*&#39;</span>);</a>
<a class="sourceLine" id="cb16-5" title="5">    }   </a>
<a class="sourceLine" id="cb16-6" title="6">  }</a>
<a class="sourceLine" id="cb16-7" title="7">}</a></code></pre></div>
</section><section id="practice-5-time-complexity" class="slide level2">
<h2>Practice 5: Time Complexity</h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">mA</span>(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="bu">Math</span>.<span class="fu">random</span>());</a>
<a class="sourceLine" id="cb17-4" title="4">  }</a>
<a class="sourceLine" id="cb17-5" title="5">}</a></code></pre></div>
</section><section id="practice-6-time-complexity" class="slide level2">
<h2>Practice 6: Time Complexity</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">mB</span>(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; i; j++)</a>
<a class="sourceLine" id="cb18-4" title="4">      <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="bu">Math</span>.<span class="fu">random</span>());</a>
<a class="sourceLine" id="cb18-5" title="5">  }</a>
<a class="sourceLine" id="cb18-6" title="6">}</a></code></pre></div>
</section><section id="practice-7-time-complexity" class="slide level2">
<h2>Practice 7: Time Complexity</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">mC</span>(<span class="dt">int</span>[ ] m) {</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m.<span class="fu">length</span>; i++) {</a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(m[i]);</a>
<a class="sourceLine" id="cb19-4" title="4">  }</a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="kw">for</span> (<span class="dt">int</span> i = m.<span class="fu">length</span> - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; ) {</a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(m[i]);</a>
<a class="sourceLine" id="cb19-7" title="7">    i--;</a>
<a class="sourceLine" id="cb19-8" title="8">  }</a>
<a class="sourceLine" id="cb19-9" title="9">}</a></code></pre></div>
</section><section id="practice-8-time-complexity" class="slide level2">
<h2>Practice 8: Time Complexity</h2>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">mD</span>(<span class="dt">int</span>[] m) {</a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m.<span class="fu">length</span>; i++) {</a>
<a class="sourceLine" id="cb20-3" title="3">    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; i; j++)</a>
<a class="sourceLine" id="cb20-4" title="4">      <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(m[i] * m[j]);</a>
<a class="sourceLine" id="cb20-5" title="5">  }</a>
<a class="sourceLine" id="cb20-6" title="6">}</a></code></pre></div>
</section></section>
<section id="analyzing-complexity-22.4" class="title-slide slide level1"><h1>Analyzing Complexity (22.4)</h1></section>
<section><section id="binary-search" class="title-slide slide level1"><h1>Binary Search</h1></section><section id="binary-search-1" class="slide level2">
<h2>Binary Search</h2>
<p>Remember binary search?</p>
<p>On a sorted array, we:</p>
<ol type="1">
<li>“Guess” that the middle element is our key.</li>
<li>If the middle element is greater or less than our key, repeat the search using the second or first half of the array, respectively</li>
<li>When you find the key, or our subarray reached zero length, stop.</li>
</ol>
</section><section id="binary-search-2" class="slide level2">
<h2>Binary Search</h2>
<div class="sourceCode" id="cb21"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">binarySearch</span>(<span class="dt">int</span>[] list, <span class="dt">int</span> key) {</a>
<a class="sourceLine" id="cb21-2" title="2">  <span class="dt">int</span> low = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="dt">int</span> high = list.<span class="fu">length</span> - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb21-4" title="4">  <span class="kw">while</span> (high &gt;= low) {</a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="dt">int</span> mid = (low + high) / <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="kw">if</span> (key &lt; list[mid])</a>
<a class="sourceLine" id="cb21-7" title="7">      high = mid - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb21-8" title="8">    <span class="kw">else</span> <span class="kw">if</span> (key == list[mid])</a>
<a class="sourceLine" id="cb21-9" title="9">      <span class="kw">return</span> mid;</a>
<a class="sourceLine" id="cb21-10" title="10">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb21-11" title="11">      low = mid + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb21-12" title="12">  }</a>
<a class="sourceLine" id="cb21-13" title="13">  <span class="kw">return</span> -low - <span class="dv">1</span>; <span class="co">// Now high &lt; low</span></a>
<a class="sourceLine" id="cb21-14" title="14">}</a></code></pre></div>
</section><section id="binary-search-3" class="slide level2">
<h2>Binary Search</h2>
<ul>
<li>Each iteration in the algorithm contains a fixed number of operations, denoted by c.</li>
<li>Let T(n) denote the time complexity for a binary search on a list of n elements.</li>
<li>Without loss of generality, assume n is a power of 2 and k = log n.</li>
</ul>
</section><section id="binary-search-4" class="slide level2">
<h2>Binary Search</h2>
<ul>
<li>Since a binary search eliminates half of the input after two comparisons:</li>
</ul>
<p><span class="math display"> \begin{aligned}T\Big(n\Big) &amp;= T  \Big(\frac{n}{2}\Big) + c = T\Big(\frac{n}{2^2}\Big) + c + c = T\Big(\frac{n}{2^k}\Big) + kc \\ &amp;= T\Big(1\Big) + c\ log\ n =1 + (log\ n) c \\ &amp;= O(log\ n) \end{aligned} </span></p>
</section></section>
<section><section id="selection-sort" class="title-slide slide level1"><h1>Selection Sort</h1></section><section id="selection-sort-algorithm" class="slide level2">
<h2>Selection Sort Algorithm</h2>
<ol type="1">
<li>Find the smallest element in the list and swaps it with the first element.</li>
<li>Find the smallest element remaining and swaps it with the first element in the remaning list</li>
<li>Repeat until only one element is left.</li>
</ol>
</section><section id="selection-sort-analysis" class="slide level2">
<h2>Selection Sort Analysis</h2>
<ul>
<li>The number of comparisons is n - 1 for the first iteration, n - 2 for the second iteration, and so on.</li>
<li>Let T(n) denote the complexity for selection sort</li>
<li>Let c denote the total number of other operations such as assignments and additional comparisons in each iteration.</li>
<li>What is Big O for Selection Sort?</li>
</ul>
</section><section id="selection-sort-analysis-1" class="slide level2">
<h2>Selection Sort Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= (n - 1) + c + (n - 2) + c + ... + 2 + c + 1 + c \\
&amp;= \frac{(n - 1)(n - 1 + 1)}{2} + c(n-1) = \frac{n^2}{2} - \frac{n}{2} +cn-c \\
&amp;= O(?) \end{aligned} </span></p>
</section><section id="selection-sort-analysis-2" class="slide level2">
<h2>Selection Sort Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= (n - 1) + c + (n - 2) + c + ... + 2 + c + 1 + c \\
&amp;= \frac{(n - 1)(n - 1 + 1)}{2} + c(n-1) = \frac{n^2}{2} - \frac{n}{2} +cn-c \\
&amp;= O(n^2) \end{aligned} </span></p>
<p>The complexity of the selection sort algorithm is <strong>O(n<sup>2</sup>)</strong>.</p>
</section></section>
<section><section id="tower-of-hanoi" class="title-slide slide level1"><h1>Tower of Hanoi</h1></section><section id="tower-of-hanoi-algorithm" class="slide level2">
<h2>Tower of Hanoi Algorithm</h2>
<ol type="1">
<li>Move the first n - 1 disks from A to C with the assistance of tower B.</li>
<li>Move disk n from A to B.</li>
<li>Move n - 1 disks from C to B with the assistance of tower A.</li>
</ol>
</section><section id="tower-of-hanoi-analysis" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<ul>
<li>The complexity of this algorithm is measured by the number of moves.</li>
<li>Let T(n) denote the number of moves for the algorithm to move n disks from tower A to tower B with <span class="math inline">T(1) = 1.</span></li>
<li>What is the time complexity of the Tower of Hanoi algorithm?</li>
</ul>
</section><section id="tower-of-hanoi-analysis-1" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
 \end{aligned} </span></p>
</section><section id="tower-of-hanoi-analysis-2" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
&amp;=2T(n-1) + 1 \\
\end{aligned} </span></p>
</section><section id="tower-of-hanoi-analysis-3" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
&amp;=2T(n-1) + 1 \\
&amp;= 2(2T(n-2)+1)+1\\
 \end{aligned} </span></p>
</section><section id="tower-of-hanoi-analysis-4" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
&amp;=2T(n-1) + 1 \\
&amp;= 2(2T(n-2)+1)+1\\
&amp;= 2(2(2T(n-3) + 1)+1)+1 \\
 \end{aligned} </span></p>
</section><section id="tower-of-hanoi-analysis-5" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
&amp;=2T(n-1) + 1 \\
&amp;= 2(2T(n-2)+1)+1\\
&amp;= 2(2(2T(n-3) + 1)+1)+1 \\
&amp;= 2^{n-1} T(1)  + 2^{n-2} + ... + 2 + 1 \\
\end{aligned} </span></p>
</section><section id="tower-of-hanoi-analysis-6" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
&amp;=2T(n-1) + 1 \\
&amp;= 2(2T(n-2)+1)+1\\
&amp;= 2(2(2T(n-3) + 1)+1)+1 \\
&amp;= 2^{n-1} T(1)  + 2^{n-2} + ... + 2 + 1 \\
&amp;= 2^{n-1} + 2^{n-2} + ... + 2 + 1 = (2^n -1 ) \\
&amp;= O(?)
\end{aligned} </span></p>
</section><section id="tower-of-hanoi-analysis-7" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n-1) + 1 + T(n-1) \\
&amp;=2T(n-1) + 1 \\
&amp;= 2(2T(n-2)+1)+1\\
&amp;= 2(2(2T(n-3) + 1)+1)+1 \\
&amp;= 2^{n-1} T(1)  + 2^{n-2} + ... + 2 + 1 \\
&amp;= 2^{n-1} + 2^{n-2} + ... + 2 + 1 = (2^n -1 ) \\
&amp;= O(2^n)
\end{aligned} </span></p>
<p>The Big O of Tower of Hanoi is <strong>O(2<sup>n</sup>)</strong>.</p>
</section><section id="tower-of-hanoi-analysis-8" class="slide level2">
<h2>Tower of Hanoi Analysis</h2>
<ul>
<li>An algorithm with O(2<sup>n</sup>) time complexity is called an exponential algorithm, and it exhibits an exponential growth rate.</li>
<li>As the input size increases, the time for the exponential algorithm grows exponentially.</li>
</ul>
</section><section id="exponential-algorithms" class="slide level2">
<h2>Exponential Algorithms</h2>
<ul>
<li>Exponential algorithms are not practical for large input size.</li>
<li>Suppose the disk is moved at a rate of 1 per second.</li>
<li>It would take 232/(365 * 24 * 60 * 60) = 136 years to move 32 disks</li>
<li>It would take 264/(365 * 24 * 60 * 60) = 585 billion years to move 64 disks.</li>
</ul>
</section><section id="recurrence-relations" class="slide level2 tinyslide">
<h2>Recurrence Relations</h2>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 22%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>Recurrence Relation</th>
<th>Result</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">T(n) = T(n/2) + O(1)</span></td>
<td><span class="math inline">T(n) = O(log\ n)</span></td>
<td>Binary search, Euclid’s GCD</td>
</tr>
<tr class="even">
<td><span class="math inline">T(n) = T(n - 1) + O(1)</span></td>
<td><span class="math inline">T(n) = O(n)</span></td>
<td>Linear search</td>
</tr>
<tr class="odd">
<td><span class="math inline">T(n) = 2T(n/2) + O(1)</span></td>
<td><span class="math inline">T(n) = O(n)</span></td>
<td>Checkpoint Question 22.20</td>
</tr>
<tr class="even">
<td><span class="math inline">T(n) = 2T(n/2) + O(n)</span></td>
<td><span class="math inline">T(n) = O(n\ log\ n)</span></td>
<td>Merge sort (Chapter 23)</td>
</tr>
<tr class="odd">
<td><span class="math inline">T(n) = T(n - 1) + O(n)</span></td>
<td><span class="math inline">T(n) = O(n^2)</span></td>
<td>Selection sort</td>
</tr>
<tr class="even">
<td><span class="math inline">T(n) = 2T(n - 1) + O(1)</span></td>
<td><span class="math inline">T(n) = O(2^n)</span></td>
<td>Tower of Hanoi</td>
</tr>
<tr class="odd">
<td><span class="math inline">T(n) = T(n - 1) + T(n - 2) + O(1)</span></td>
<td><span class="math inline">T(n) = O( 2^n )</span></td>
<td>Recursive Fibonacci algorithm</td>
</tr>
</tbody>
</table>
</section><section id="comparing-common-growth-rates" class="slide level2 tinyslide">
<h2>Comparing Common Growth Rates</h2>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Name</th>
<th>n=25</th>
<th>n=50</th>
<th>f(50)/f(25)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>O(1)</td>
<td>Constant time</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>O(log n)</td>
<td>Logarithmic time</td>
<td>4.64</td>
<td>5.64</td>
<td>1.21</td>
</tr>
<tr class="odd">
<td>O(n)</td>
<td>Linear time</td>
<td>25</td>
<td>50</td>
<td>2</td>
</tr>
<tr class="even">
<td>O(n log n)</td>
<td>Log-linear time</td>
<td>116</td>
<td>282</td>
<td>2.43</td>
</tr>
<tr class="odd">
<td>O(n<sup>2</sup>)</td>
<td>Quadratic time</td>
<td>625</td>
<td>2,500</td>
<td>4</td>
</tr>
<tr class="even">
<td>O(n<sup>3</sup>)</td>
<td>Cubic time</td>
<td>15,625</td>
<td>125,000</td>
<td>8</td>
</tr>
<tr class="odd">
<td>O(2<sup>n</sup>)</td>
<td>Exponential time</td>
<td>3.36 * 10<sup>7</sup></td>
<td>1.27 * 10<sup>15</sup></td>
<td>3.35 * 10<sup>7</sup></td>
</tr>
</tbody>
</table>
</section><section id="comparing-growth-rates" class="slide level2">
<h2>Comparing Growth Rates</h2>
<p>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n)</p>
<p>&lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>)</p>
</section><section id="comparing-growth-rates-1" class="slide level2">
<h2>Comparing Growth Rates</h2>
<img data-src="lecture5-diagram2.png" title="fig:" alt="Comparing Growth Rates" class="stretch" />
</section><section id="comparing-growth-rates-2" class="slide level2">
<h2>Comparing Growth Rates</h2>
<figure>
<img data-src="lecture5-diagram3.png" alt="Comparing Growth Rates (from bigocheatsheet.com)" width="700" /><figcaption>Comparing Growth Rates (from bigocheatsheet.com)</figcaption>
</figure>
</section></section>
<section><section id="fibonacci-using-dynamic-programming-22.5" class="title-slide slide level1"><h1>Fibonacci Using Dynamic Programming (22.5)</h1></section><section id="recursive-fibonacci" class="slide level2">
<h2>Recursive Fibonacci</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb22-1" title="1"><span class="co">/**</span> The method for finding the Fibonacci number <span class="co">*/</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">fib</span>(<span class="dt">long</span> index) {</a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="kw">if</span> (index == <span class="dv">0</span>) <span class="co">// Base case</span></a>
<a class="sourceLine" id="cb22-4" title="4">    <span class="kw">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-5" title="5">  <span class="kw">else</span> <span class="kw">if</span> (index == <span class="dv">1</span>) <span class="co">// Base case</span></a>
<a class="sourceLine" id="cb22-6" title="6">    <span class="kw">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb22-7" title="7">  <span class="kw">else</span> <span class="co">// Reduction and recursive calls</span></a>
<a class="sourceLine" id="cb22-8" title="8">    <span class="kw">return</span> <span class="fu">fib</span>(index - <span class="dv">1</span>) + <span class="fu">fib</span>(index - <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb22-9" title="9">}</a></code></pre></div>
</section><section id="recursive-fibonacci-1" class="slide level2">
<h2>Recursive Fibonacci</h2>
<ul>
<li>We can now prove that the complexity of this algorithm is O(2<sup>n</sup>).</li>
<li>For convenience, let the index be n.</li>
<li>Let T(n) denote the complexity for the algorithm that finds fib(n)</li>
<li>Let c denote the constant time for comparing the index with 0 and 1;</li>
<li>That is, T(1) and T(0) are c.</li>
</ul>
</section><section id="recursive-fibonacci-2" class="slide level2">
<h2>Recursive Fibonacci</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n - 1) + T(n - 2) + c \\
&amp;\leq 2T(n-1)+c \\
&amp;\leq 2(2T(n-2)+c)+c \\
&amp;= 2^2 T(n - 2) + 2c + c \\
&amp;= O(?)\end{aligned}</span></p>
</section><section id="recursive-fibonacci-3" class="slide level2">
<h2>Recursive Fibonacci</h2>
<p><span class="math display"> \begin{aligned} T(n) &amp;= T(n - 1) + T(n - 2) + c \\
&amp;\leq 2T(n-1)+c \\
&amp;\leq 2(2T(n-2)+c)+c \\
&amp;= 2^2 T(n - 2) + 2c + c \\
&amp;= O(2^n)\end{aligned}</span></p>
</section><section id="recursive-fibonacci-4" class="slide level2">
<h2>Recursive Fibonacci</h2>
<ul>
<li>O(2<sup>n</sup>) this algorithm is not efficient.</li>
<li>What makes this algorithm so inefficient?</li>
</ul>
</section><section id="recursive-fibonacci-5" class="slide level2">
<h2>Recursive Fibonacci</h2>
<ul>
<li class="fragment">O(2<sup>n</sup>) this algorithm is not efficient.</li>
<li class="fragment">What makes this algorithm so inefficient?</li>
<li class="fragment">It is inefficient because it makes redundant calculations</li>
<li class="fragment"><span class="math inline">fib(4) = fib(3) + fib(2)</span></li>
<li class="fragment"><span class="math inline">fib(3) = fib (2) + fib(1)</span></li>
<li class="fragment">…</li>
<li class="fragment">What if we saved fib(2) instead of calculating it twice?</li>
</ul>
</section></section>
<section><section id="improved-fibonacci" class="title-slide slide level1"><h1>Improved Fibonacci</h1></section><section id="improved-fibonacci-1" class="slide level2">
<h2>Improved Fibonacci</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb23-1" title="1">  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">long</span> <span class="fu">fib</span>(<span class="dt">long</span> n) {   </a>
<a class="sourceLine" id="cb23-2" title="2">    <span class="dt">long</span> f0 = <span class="dv">0</span>; <span class="co">// For fib(0)</span></a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="dt">long</span> f1 = <span class="dv">1</span>; <span class="co">// For fib(1)</span></a>
<a class="sourceLine" id="cb23-4" title="4">    <span class="dt">long</span> f2 = <span class="dv">1</span>; <span class="co">// For fib(2)</span></a>
<a class="sourceLine" id="cb23-5" title="5">    <span class="kw">if</span> (n == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb23-6" title="6">      <span class="kw">return</span> f0;</a>
<a class="sourceLine" id="cb23-7" title="7">    <span class="kw">else</span> <span class="kw">if</span> (n == <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb23-8" title="8">      <span class="kw">return</span> f1;</a>
<a class="sourceLine" id="cb23-9" title="9">    <span class="kw">else</span> <span class="kw">if</span> (n == <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb23-10" title="10">      <span class="kw">return</span> f2;</a>
<a class="sourceLine" id="cb23-11" title="11">    ...</a></code></pre></div>
</section><section id="improved-fibonacci-o" class="slide level2">
<h2>Improved Fibonacci O(?)</h2>
<div class="sourceCode" id="cb24"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb24-1" title="1">    ...</a>
<a class="sourceLine" id="cb24-2" title="2">    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">3</span>; i &lt;= n; i++) {</a>
<a class="sourceLine" id="cb24-3" title="3">      f0 = f1;</a>
<a class="sourceLine" id="cb24-4" title="4">      f1 = f2;</a>
<a class="sourceLine" id="cb24-5" title="5">      f2 = f0 + f1;</a>
<a class="sourceLine" id="cb24-6" title="6">    }  </a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="kw">return</span> f2;</a>
<a class="sourceLine" id="cb24-8" title="8">  }</a></code></pre></div>
</section><section id="improved-fibonacci-analysis" class="slide level2">
<h2>Improved Fibonacci Analysis</h2>
<p>This improved Fibonacci algorithm is <span class="math inline">O(n)</span></p>
</section></section>
<section><section id="greatest-common-divisors" class="title-slide slide level1"><h1>Greatest Common Divisors</h1></section><section id="greatest-common-divisors-1" class="slide level2">
<h2>Greatest Common Divisors</h2>
<ul>
<li>In algebra we seek to find the Greatest Common Divisors (GCD)</li>
<li>For example, the GCD of 12 and 8 is 4</li>
<li>There are different solutions for GCD.<br />
</li>
<li>For this exercise, m and n are our inputs and we assume <span class="math inline">m \geq n</span>.</li>
</ul>
</section><section id="brute-force-methods" class="slide level2">
<h2>Brute Force Methods</h2>
<ul>
<li><strong>Brute force</strong> refers to an algorithmic approach that solves a problem in the simplest or most direct or obvious way.</li>
<li>As a result, such an algorithm can end up doing far more work to solve a given problem than a cleverer or more sophisticated algorithm might do.</li>
<li>On the other hand, a brute-force algorithm is often easier to implement than a more sophisticated one and, because of this simplicity, sometimes it can be more efficient.</li>
</ul>
</section><section id="gcd-brute-force" class="slide level2">
<h2>GCD Brute Force</h2>
<ul>
<li>Given integers <em>m</em> and <em>n</em>, check every element from 2 up to the larger of <em>m</em> and <em>n</em> to see if it is a divisor of both</li>
<li>Return the GCD</li>
</ul>
</section><section id="gcd-1-brute-force-o" class="slide level2">
<h2>GCD 1: Brute Force O(?)</h2>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">gcd</span>(<span class="dt">int</span> m, <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="dt">int</span> gcd = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb25-3" title="3">  <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">2</span>; k &lt;= m &amp;&amp; k &lt;= n; k++) {</a>
<a class="sourceLine" id="cb25-4" title="4">    <span class="kw">if</span> (m % k == <span class="dv">0</span> &amp;&amp; n % k == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb25-5" title="5">      gcd = k;</a>
<a class="sourceLine" id="cb25-6" title="6">  }</a>
<a class="sourceLine" id="cb25-7" title="7">  <span class="kw">return</span> gcd;</a>
<a class="sourceLine" id="cb25-8" title="8">}</a></code></pre></div>
</section><section id="gcd-1-brute-force" class="slide level2">
<h2>GCD 1: Brute Force</h2>
<ul>
<li class="fragment"><span class="math inline">O(n)</span></li>
<li class="fragment">How could we improve it?</li>
<li class="fragment">What if we checked from the top down instead of bottom up?</li>
</ul>
</section><section id="gcd-2-o" class="slide level2">
<h2>GCD 2 O(?)</h2>
<div class="sourceCode" id="cb26"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> k = n; k &gt;= <span class="dv">1</span>; k--) {</a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="kw">if</span> (m % k == <span class="dv">0</span> &amp;&amp; n % k == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb26-3" title="3">    gcd = k;</a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb26-5" title="5">  }</a>
<a class="sourceLine" id="cb26-6" title="6">}</a></code></pre></div>
</section><section id="gcd-2" class="slide level2">
<h2>GCD 2</h2>
<ul>
<li class="fragment">Better than GCD Brute Force 1</li>
<li class="fragment">What is the time complexity?</li>
<li class="fragment">Worst case is still <span class="math inline">O(n)</span></li>
<li class="fragment">Observation: a divisor cannot by more than half of a number. So we can begin our search there instead of at n.</li>
</ul>
</section><section id="gcd-3-o" class="slide level2">
<h2>GCD 3 O(?)</h2>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">for</span> (<span class="dt">int</span> k = m / <span class="dv">2</span>; k &gt;= <span class="dv">1</span>; k--) {</a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="kw">if</span> (m % k == <span class="dv">0</span> &amp;&amp; n % k == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb27-3" title="3">    gcd = k;</a>
<a class="sourceLine" id="cb27-4" title="4">    <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb27-5" title="5">  }</a>
<a class="sourceLine" id="cb27-6" title="6">}</a></code></pre></div>
</section><section id="gcd-3" class="slide level2">
<h2>GCD 3</h2>
<ul>
<li class="fragment">Oops, this algorithm is faster but incorrect</li>
<li class="fragment">It doesn’t consider than <em>n</em> can be a divisor for <em>m</em></li>
</ul>
</section><section id="gcd-4-o" class="slide level2">
<h2>GCD 4 O(?)</h2>
<div class="sourceCode" id="cb28"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">gcd</span>(<span class="dt">int</span> m, <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb28-2" title="2">  <span class="dt">int</span> gcd = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb28-3" title="3">  <span class="kw">if</span> (m % n == <span class="dv">0</span>) <span class="kw">return</span> n;</a>
<a class="sourceLine" id="cb28-4" title="4">  <span class="kw">for</span> (<span class="dt">int</span> k = n / <span class="dv">2</span>; k &gt;= <span class="dv">1</span>; k--) {</a>
<a class="sourceLine" id="cb28-5" title="5">    <span class="kw">if</span> (m % k == <span class="dv">0</span> &amp;&amp; n % k == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb28-6" title="6">      gcd = k;</a>
<a class="sourceLine" id="cb28-7" title="7">      <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb28-8" title="8">    }</a>
<a class="sourceLine" id="cb28-9" title="9">  }</a>
<a class="sourceLine" id="cb28-10" title="10">  <span class="kw">return</span> gcd;</a>
<a class="sourceLine" id="cb28-11" title="11">}</a></code></pre></div>
</section><section id="gcd-4" class="slide level2">
<h2>GCD 4</h2>
<ul>
<li class="fragment">Assuming m <span class="math inline">\geq</span> n, the for loop is executed at most n/2 times</li>
<li class="fragment">This cuts the time in half from the previous algorithm</li>
<li class="fragment">T time complexity is still <span class="math inline">O(n)</span>, but practically, it is much faster than GCD 2</li>
</ul>
</section><section id="euclid" class="slide level2">
<h2>Euclid</h2>
<ul>
<li>Euclid was a Greek Mathematician</li>
<li>the “father of geometry”</li>
<li>Born around 300 B.C.</li>
<li>Invented a solution to Greatest Common Divisor</li>
</ul>
</section><section id="euclids-gcd" class="slide level2">
<h2>Euclid’s GCD</h2>
<div class="sourceCode" id="cb29"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">gcd</span>(<span class="dt">int</span> m, <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb29-2" title="2">  <span class="kw">if</span> (m % n == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb29-3" title="3">    <span class="kw">return</span> n;</a>
<a class="sourceLine" id="cb29-4" title="4">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="kw">return</span> <span class="fu">gcd</span>(n, m % n);</a>
<a class="sourceLine" id="cb29-6" title="6">}</a></code></pre></div>
</section><section id="euclids-gcd-analysis" class="slide level2">
<h2>Euclid’s GCD Analysis</h2>
<ul>
<li class="fragment">Best case is when <span class="math inline">m \% n = 0 : O(n)</span></li>
<li class="fragment">Average case is hard to determine</li>
<li class="fragment">What about worst case?</li>
</ul>
</section><section id="euclids-gcd-analysis-1" class="slide level2">
<h2>Euclid’s GCD Analysis</h2>
<ul>
<li>If <span class="math inline">n \leq m / 2, m \% n &lt; m / 2</span> since the remainder of m divided by n is always less than n.</li>
<li>If <span class="math inline">n \gt m / 2, m \% n = m – n \lt m / 2</span>.</li>
<li>Therefore <span class="math inline">m \% n &lt; m/2</span></li>
<li>Let’s follow the recursive calls</li>
</ul>
</section><section id="euclids-gcd-analysis-2" class="slide level2">
<h2>Euclid’s GCD Analysis</h2>
<ul>
<li class="fragment"><span class="math inline">gcd(m, n)</span></li>
<li class="fragment"><span class="math inline">gcd(n, m \% n)</span></li>
<li class="fragment"><span class="math inline">gcd(m \% n, n \% (m \% n))</span></li>
<li class="fragment">…</li>
</ul>
</section><section id="euclids-gcd-analysis-3" class="slide level2">
<h2>Euclid’s GCD Analysis</h2>
<ul>
<li class="fragment">Since <span class="math inline">m % n &lt; m / 2</span> and <span class="math inline">n % (m % n) &lt; n / 2</span> ,the argument passed to the gcd method is reduced by half after every two iterations.</li>
<li class="fragment">After invoking gcd two times, the second parameter is less than n/2.</li>
<li class="fragment">After invoking gcd four times, the second parameter is less than n/4.</li>
</ul>
</section><section id="euclids-gcd-analysis-4" class="slide level2">
<h2>Euclid’s GCD Analysis</h2>
<ul>
<li>After invoking gcd six times, the second parameter is less than <span class="math inline">\frac{n}{2^3}</span>.</li>
<li>Let k be the number of times gcd is invoked</li>
<li>After invoking gcd k times, the second parameter is less than ______</li>
</ul>
</section><section id="euclids-gcd-analysis-5" class="slide level2">
<h2>Euclid’s GCD Analysis</h2>
<ul>
<li class="fragment">After invoking gcd k times, the second parameter is less than <span class="math inline">\frac{n}{2^{k/2}}</span> which is greater than or equal to 1:</li>
<li class="fragment">$ 1 =&gt; n 2^{k/2} =&gt; k 2 n $</li>
<li class="fragment">Therefore, <span class="math inline">k \leq 2\log n</span></li>
<li class="fragment">So the time complexity of Euclid’s GCD is:</li>
<li class="fragment"><span class="math inline">O(\log n)</span></li>
</ul>
</section></section>
    </div>
  </div>

  <script src="../../../presentation/reveal.js/lib/js/head.min.js"></script>
  <script src="../../../presentation/reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: '../../../presentation/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../../presentation/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: '../../../presentation/reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
