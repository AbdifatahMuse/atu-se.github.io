<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="dcterms.date" content="2019-02-15">
  <title>DSA Lecture</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/reveal.css">
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/theme/beige.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../../../presentation/reveal.js/css/print/pdf.css' : '../../../presentation/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="../../../presentation/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">DSA Lecture</h1>
  <p class="subtitle">3. Lists, Stacks, Queues, and Priority Queues</p>
  <p class="date">February 15, 2019</p>
</section>

<section><section id="introduction-201" class="title-slide slide level1"><h1>Introduction (20.1)</h1></section><section id="introduction" class="slide level2">
<h2>Introduction</h2>
<ul>
<li>Choosing the best data structures and algorithms for a particular task is one of the keys to developing high-performance software.</li>
<li>A data structure is a collection of data organized in some fashion. The structure not only stores data but also supports operations for accessing and manipulating the data.</li>
<li>In object-oriented thinking, a data structure, also known as a container or container object, is an object that stores other objects, referred to as data or elements.</li>
</ul>
</section></section>
<section><section id="collections-202" class="title-slide slide level1"><h1>Collections (20.2)</h1></section><section id="collections" class="slide level2">
<h2>20.2 Collections</h2>
<p>The Collection interface defines the common operations for lists, vectors, stacks, queues, priority queues, and sets.</p>
</section><section id="collections-1" class="slide level2">
<h2>Collections</h2>
<p>The Java Collections Framework supports two types of containers:</p>
<ul>
<li>One for storing a collection of elements is simply called a collection.</li>
<li>The other, for storing key/value pairs, is called a map.</li>
</ul>
</section><section id="maps" class="slide level2">
<h2>Maps</h2>
<ul>
<li>Maps are efficient data structures for quickly searching an element using a key.</li>
<li>We will introduce maps in the next chapter.</li>
</ul>
</section><section id="collections-2" class="slide level2">
<h2>Collections</h2>
<ul>
<li><code>Set</code>s store a group of non-duplicate elements.</li>
<li><code>List</code>s store an ordered collection of elements.</li>
<li><code>Stack</code>s store objects that are processed in a last-in, first-out fashion.</li>
<li><code>Queue</code>s store objects that are processed in a first-in, first-out fashion.</li>
<li><code>PriorityQueue</code>s store objects that are processed in the order of their priorities.</li>
</ul>
</section><section id="packaging" class="slide level2">
<h2>Packaging</h2>
<ul>
<li>All the interfaces and classes defined in the Java Collections Framework are grouped in the java.util package</li>
</ul>
</section><section id="design" class="slide level2">
<h2>Design</h2>
<ul>
<li>The design of the Java Collections Framework is an excellent example of using interfaces, abstract classes, and concrete classes.
<ul>
<li>The interfaces define the framework.</li>
<li>The abstract classes provide partial implementation.</li>
<li>The concrete classes implement the interfaces with concrete data structures.</li>
</ul></li>
</ul>
</section><section id="collectione" class="slide level2">
<h2>Collection&lt;E&gt;</h2>
<ul>
<li>+add(o: E): boolean</li>
<li>+isEmpty(): boolean</li>
<li>+contains(o: Object): boolean</li>
<li>+size(): int</li>
</ul>
</section><section id="collectione-1" class="slide level2">
<h2>Collection&lt;E&gt;</h2>
<ul>
<li>+containsAll(c: Collection&lt;?&gt;): boolean</li>
<li>+remove(o: Object): boolean</li>
<li>+addAll(c: Collection&lt;? extends E&gt;): boolean</li>
<li>+equals(o: Object): boolean</li>
<li>+clear(): void</li>
</ul>
</section><section id="collectione-2" class="slide level2">
<h2>Collection&lt;E&gt;</h2>
<ul>
<li>+hashCode(): int</li>
<li>+removeAll(c: Collection&lt;?&gt;): boolean</li>
<li>+retainAll(c: Collection&lt;?&gt;): boolean</li>
<li>+toArray(): Object[]</li>
</ul>
</section><section id="collection-interface" class="slide level2">
<h2>Collection Interface</h2>
<ul>
<li>The examples I have just shown used ArrayList</li>
<li>But the methods are for the Collections interface</li>
<li>All of the methods will also work for <code>HashSet</code>, <code>LinkedList</code>, <code>Vector</code>, and <code>Stack</code>.</li>
</ul>
</section><section id="additional-interfaces" class="slide level2">
<h2>Additional Interfaces</h2>
<ul>
<li>All the concrete classes in the Java Collections Framework implement the <code>java.lang.Cloneable</code> and <code>java.io.Serializable</code> interfaces</li>
<li>… Except that java.util.PriorityQueue does not implement the <code>Cloneable</code> interface. Thus, all instances of <code>Cloneable</code> except priority queues can be cloned and all instances of <code>Cloneable</code> can be serialized.</li>
</ul>
</section></section>
<section><section id="iterators-203" class="title-slide slide level1"><h1>Iterators (20.3)</h1></section><section id="iterators" class="slide level2">
<h2>Iterators</h2>
<ul>
<li>Each collection is <code>Iterable</code>.</li>
<li>You can obtain its <code>Iterator</code> object to traverse all the elements in the collection.</li>
</ul>
</section><section id="iterator-demo" class="slide level2">
<h2><code>Iterator</code> Demo</h2>
</section></section>
<section><section id="lists-204" class="title-slide slide level1"><h1>Lists (20.4)</h1></section><section id="lists" class="slide level2">
<h2>Lists</h2>
<p>The <code>List</code> interface extends the <code>Collection</code> interface and defines a collection for storing elements in a sequential order. To create a list, use one of its two concrete classes: <code>ArrayList</code> or <code>LinkedList</code>.</p>
</section><section id="liste" class="slide level2">
<h2>List&lt;E&gt;</h2>
<ul>
<li>+add(index: int, element: Object): boolean</li>
<li>+addAll(index: int, c: Collection&lt;? extends E&gt;): boolean</li>
<li>+get(index: int): E</li>
<li>+indexOf(element: Object): int</li>
<li>+lastIndexOf(element: Object): int</li>
</ul>
</section><section id="liste-1" class="slide level2">
<h2>List&lt;E&gt;</h2>
<ul>
<li>+listIterator(): ListIterator<E></li>
<li>+listIterator(startIndex: int): ListIterator<E></li>
<li>+remove(index: int): E</li>
<li>+set(index: int, element: Object): Object</li>
<li>+subList(fromIndex: int, toIndex: int): List<E></li>
</ul>
</section><section id="arraylist-vs-linkedlist" class="slide level2">
<h2>ArrayList vs. LinkedList</h2>
<ul>
<li>The <code>ArrayList</code> class and the <code>LinkedList</code> class are two concrete implementations of the List interface.</li>
<li><code>ArrayList</code> stores elements in an array.</li>
<li><code>LinkedList</code> stores elements in a linked list.</li>
</ul>
</section><section id="arraylist-vs-linkedlist-1" class="slide level2">
<h2>ArrayList vs. LinkedList</h2>
<ul>
<li>If you need to support random access through an index without inserting or removing elements at the beginning of the list, ArrayList offers the most efficient collection.</li>
<li>If, however, your application requires the insertion or deletion of elements at the beginning of the list, you should choose LinkedList.</li>
</ul>
</section><section id="arraylist" class="slide level2">
<h2>ArrayList</h2>
<ul>
<li><code>ArrayList</code> is a resizable-array implementation of the List interface.</li>
<li>Each <code>ArrayList</code> instance has a capacity, which is the size of the array used to store the elements in the list.</li>
<li>If the capacity of the array is exceeded, a larger new array is created and all the elements from the current array are copied to the new array.</li>
</ul>
</section><section id="arraylist-1" class="slide level2">
<h2>ArrayList</h2>
<ul>
<li>It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically.</li>
<li>An ArrayList does not automatically shrink. You can use the trimToSize() method to reduce the array capacity to the size of the list.</li>
<li>An ArrayList can be constructed using its no-arg constructor, ArrayList(Collection), or ArrayList(initialCapacity).</li>
</ul>
</section><section id="arrayliste" class="slide level2">
<h2>ArrayList&lt;E&gt;</h2>
<ul>
<li><code>ArrayList</code> provides methods for manipulating the size of the array used internally to store the list, as shown in Figure 20.5.
<ul>
<li>+ArrayList()</li>
<li>+ArrayList(c: Collection&lt;? extends E&gt;)</li>
<li>+ArrayList(initialCapacity: int)</li>
<li>+trimToSize(): void</li>
</ul></li>
</ul>
</section><section id="linkedlist" class="slide level2">
<h2>LinkedList</h2>
<ul>
<li>A list can grow or shrink dynamically. Once it is created, an array is fixed. If your application does not require the insertion or deletion of elements, an array is the most efficient data structure.</li>
<li>In addition to implementing the List interface, this class provides the methods for retrieving, inserting, and removing elements from both ends of the list.</li>
</ul>
</section><section id="linkedliste" class="slide level2">
<h2>LinkedList&lt;E&gt;</h2>
<ul>
<li>+LinkedList()</li>
<li>+LinkedList(c: Collection&lt;? extends E&gt;)</li>
<li>+addFirst(element: E): void</li>
<li>+addLast(element: E): void</li>
<li>+getFirst(): E</li>
<li>+getLast(): E</li>
<li>+removeFirst(): E</li>
<li>+removeLast(): E</li>
</ul>
</section><section id="linkedlist-and-arraylist-demo" class="slide level2">
<h2>LinkedList and ArrayList Demo</h2>
</section></section>
<section><section id="comparator-interface-205" class="title-slide slide level1"><h1><code>Comparator</code> Interface (20.5)</h1></section><section id="comparator" class="slide level2">
<h2>Comparator</h2>
<ul>
<li><code>Comparator</code> can be used to compare the objects of a class that doesn’t implement <code>Comparable</code>.</li>
<li>The <code>Comparable</code> interface defines the compareTo method, which is used to compare two elements of the same class that implement the <code>Comparable</code> interface.</li>
<li>What if the elements’ classes do not implement the <code>Comparable</code> interface? Can these elements be compared? * You can define a comparator to compare the elements of different classes. To do so, define a class that implements the <code>java.util.Comparator&lt;T&gt;</code> interface and overrides its <code>compare</code> method.</li>
</ul>
</section><section id="comparator-demo" class="slide level2">
<h2>Comparator Demo</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">public</span> <span class="kw">class</span> GeometricObjectComparator</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="kw">implements</span> <span class="bu">Comparator</span>&lt;GeometricObject&gt;, java.<span class="fu">io</span>.<span class="fu">Serializable</span> {</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compare</span>(GeometricObject o1, GeometricObject o2) {</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="dt">double</span> area1 = o1.<span class="fu">getArea</span>();</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="dt">double</span> area2 = o2.<span class="fu">getArea</span>();</a>
<a class="sourceLine" id="cb1-6" title="6">  </a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="kw">if</span> (area1 &lt; area2)</a>
<a class="sourceLine" id="cb1-8" title="8">      <span class="kw">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">else</span> <span class="kw">if</span> (area1 == area2)</a>
<a class="sourceLine" id="cb1-10" title="10">      <span class="kw">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-12" title="12">      <span class="kw">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb1-13" title="13">  }</a>
<a class="sourceLine" id="cb1-14" title="14">}</a></code></pre></div>
</section><section id="comparator-demo-1" class="slide level2">
<h2>Comparator Demo</h2>
</section></section>
<section><section id="static-methods-206" class="title-slide slide level1"><h1>Static Methods (20.6)</h1></section><section id="list-static-methods" class="slide level2">
<h2>List Static Methods</h2>
<ul>
<li>+sort(list: List): void</li>
<li>+sort(list: List, c: Comparator): void</li>
<li>+binarySearch(list: List, key: Object): int</li>
<li>+binarySearch(list: List, key: Object, c: * Comparator): int</li>
<li>+reverse(list: List): void</li>
<li>+reverseOrder(): Comparator</li>
</ul>
</section><section id="list-static-methods-1" class="slide level2">
<h2>List Static Methods</h2>
<ul>
<li>+shuffle(list: List): void</li>
<li>+shuffle(list: List, rmd: Random): void</li>
<li>+copy(des: List, src: List): void</li>
<li>+nCopies(n: int, o: Object): List</li>
<li>+fill(list: List, o: Object): void</li>
</ul>
</section><section id="collection-static-methods" class="slide level2">
<h2>Collection Static Methods</h2>
<ul>
<li>+max(c: Collection): Object</li>
<li>+max(c: Collection, c: Comparator): Object</li>
<li>+min(c: Collection): Object</li>
<li>+min(c: Collection, c: Comparator): Object</li>
<li>+disjoint(c1: Collection, c2: Collection): boolean</li>
<li>+frequency(c: Collection, o: Object): int</li>
</ul>
</section></section>
<section id="case-study-bouncing-balls-207" class="title-slide slide level1"><h1>Case Study: Bouncing Balls (20.7)</h1></section>
<section><section id="vector-and-stack-classes-208" class="title-slide slide level1"><h1><code>Vector</code> and <code>Stack</code> Classes (20.8)</h1></section><section id="vectors-and-stacks" class="slide level2">
<h2>Vectors and Stacks</h2>
<ul>
<li><code>Vector</code> is a subclass of <code>AbstractList</code>,</li>
<li><code>Stack</code> is a subclass of <code>Vector</code> in the Java API.</li>
<li>The Vector class preceded the creation of the Java Collections Framework</li>
<li>These classes were redesigned to fit into the Java Collections Framework, but all their old-style methods are retained for compatibility.</li>
</ul>
</section><section id="vector" class="slide level2">
<h2>Vector</h2>
<ul>
<li>Vector is the same as ArrayList, except that it contains synchronized methods for accessing and modifying the vector.</li>
<li>Synchronized methods can prevent data corruption when a vector is accessed and modified by two or more threads concurrently</li>
<li>For the many applications that do not require synchronization, using <code>ArrayList</code> is more efficient than using <code>Vector</code>.</li>
</ul>
</section><section id="stack" class="slide level2">
<h2>Stack</h2>
<ul>
<li>In the Java Collections Framework, Stack is implemented as an extension of Vector, as illustrated in Figure 20.11.</li>
<li>Vector is extended to provide a last-in, first out (LIFO) data structure</li>
</ul>
</section><section id="stacke" class="slide level2">
<h2>Stack&lt;E&gt;</h2>
<ul>
<li>+Stack()</li>
<li>+empty(): boolean</li>
<li>+peek(): E</li>
<li>+pop(): E</li>
<li>+push(o: E): E</li>
<li>+search(o: Object): int</li>
</ul>
</section></section>
<section><section id="queues-and-priorityqueues-209" class="title-slide slide level1"><h1><code>Queues</code> and <code>PriorityQueue</code>s (20.9)</h1></section><section id="queues-and-priorityqueues" class="slide level2">
<h2>Queues and PriorityQueues</h2>
<ul>
<li>The <code>Queue</code> interface extends java.util.Collection with additional insertion, extraction, and inspection operations</li>
<li>A queue is a first-in, first-out (FIFO) data structure. Elements are appended to the end of the queue and are removed from the beginning of the queue.</li>
<li>In a priority queue, elements are assigned priorities. When accessing elements, the element with the highest priority is removed first.</li>
</ul>
</section><section id="queuee" class="slide level2">
<h2>Queue&lt;E&gt;</h2>
<ul>
<li>+offer(element: E): boolean</li>
<li>+poll(): E</li>
<li>+remove(): E</li>
<li>+peek(): E</li>
<li>+element(): E</li>
</ul>
</section><section id="deque-and-linkedlist" class="slide level2">
<h2>Deque and LinkedList</h2>
<ul>
<li>The LinkedList class implements the <code>Deque</code> interface</li>
<li><code>Deque</code> extends <code>Queue</code></li>
<li><code>Deque</code> supports element insertion and removal at both ends. The name “deque” is short for “double-ended queue” and is usually pronounced “deck”.</li>
</ul>
</section><section id="priority-queue-demo" class="slide level2">
<h2>Priority Queue Demo</h2>
</section></section>
<section><section id="case-study-evaluating-expressions-2010" class="title-slide slide level1"><h1>Case Study: Evaluating Expressions (20.10)</h1></section><section id="evaluating-expressions" class="slide level2">
<h2>Evaluating Expressions</h2>
<ul>
<li>Stacks can be used to evaluate expressions.</li>
</ul>
</section><section id="evaluating-expressions-demo" class="slide level2">
<h2>Evaluating Expressions Demo</h2>
</section></section>
<section><section id="summary" class="title-slide slide level1"><h1>Summary</h1></section><section id="summary-1" class="slide level2">
<h2>Summary</h2>
<ol type="1">
<li>The Java Collections Framework supports sets, lists, queues, and maps. They are defined in the interfaces <code>Set</code>, <code>List</code>, <code>Queue</code>, and <code>Map</code>.</li>
<li>A list stores an ordered collection of elements.</li>
<li>All the concrete classes except <code>PriorityQueue</code> in the Java Collections Framework implement the <code>Cloneable</code> and <code>Serializable</code> interfaces. Thus, their instances can be cloned and serialized.</li>
</ol>
</section><section id="summary-2" class="slide level2">
<h2>Summary</h2>
<ol start="4" type="1">
<li>To allow duplicate elements to be stored in a collection, you need to use a list. A list not only can store duplicate elements but also allows the user to specify where they are stored. The user can access elements by an index.</li>
<li>Two types of lists are supported: <code>ArrayList</code> and <code>LinkedList</code>. <code>ArrayList</code> is a resizable-array implementation of the <code>List</code> interface. All the methods in <code>ArrayList</code> are defined in <code>List</code>.</li>
</ol>
</section><section id="summary-3" class="slide level2">
<h2>Summary</h2>
<ol start="6" type="1">
<li><code>LinkedList</code> is a linked-list implementation of the <code>List</code> interface. In addition to implementing the <code>List</code> interface, this class provides the methods for retrieving, inserting, and removing elements from both ends of the list.</li>
<li>Comparator can be used to compare the objects of a class that doesn’t implement Comparable.</li>
</ol>
</section><section id="summary-4" class="slide level2">
<h2>Summary</h2>
<ol start="8" type="1">
<li>The <code>Vector</code> class extends the Abstract <code>List</code> class. Starting with Java 2, Vector has been the same as <code>ArrayList</code>, except that the methods for accessing and modifying the vector are synchronized. The Stack class extends the Vector class and provides several methods for manipulating the stack.</li>
<li>The <code>Queue</code> interface represents a queue. The <code>PriorityQueue</code> class implements <code>Queue</code> for a priority queue.</li>
</ol>
</section></section>
    </div>
  </div>

  <script src="../../../presentation/reveal.js/lib/js/head.min.js"></script>
  <script src="../../../presentation/reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: '../../../presentation/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../../presentation/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: '../../../presentation/reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
